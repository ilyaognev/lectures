# RESTful

## Принципы RESTful архитектуры

REST — это аббревиатура от Representational State Transfer ("передача состояния представления"). Это согласованный набор
архитектурных принципов для создания более масштабируемой и гибкой сети. Архитектура REST описывается шестью
ограничениями. Эти ограничения, применительно к архитектуре, первоначально были представлены Роем Филдингом (Roy
Fielding) в его докторской диссертации и определяют основы RESTful стиля.

### Клиент-сервер

Первое ограничение указывает, что сеть должна состоять из клиентов и серверов. Сервер — это система, который имеет
требуемые ресурсы, а клиент — это система, которой нужно взаимодействовать с ресурсами, хранящимися на сервере.

Альтернатива клиент-серверной архитектуре, построенная без REST — это интеграция, основанная на событиях. В этой модели,
каждый компонент непрерывно передает события, перехватывая соответствующие события из других компонентов. В ней нет
взаимодействия point-to-point, только отправитель и получатели. REST требует взаимодействия один-к-одному, поэтому
архитектура, основанная на событиях не будет удовлетворять требованиям RESTful.

### Stateless

Отсутствие состояния (Stateless) подразумевает собой то, что необходимое состояние для обработки запроса содержится в
самом запросе, либо в рамках URI, параметрах строки запроса, тела или заголовках. URI уникально идентифицирует ресурс и
тело, содержит состояние (или изменение состояния) этого ресурса. После того как сервер завершит обработку, состояние
или его часть отдается обратно клиенту через заголовки, статус и тело ответа. В RESTful, клиент должен включать всю
информацию для сервера для выполнения запроса, выполняя отправку смежных представлений ресурсов, если требуемое
состояние должно охватывать несколько запросов. Отсутствие состояний обеспечивает большую масштабируемость, так как
сервер не должен поддерживать или общаться через состояние сеанса. Кроме того, балансировщику нагрузки не придется
беспокоиться о связанности сессии и системы.

### Единообразие интерфейса

Это ограничение гарантирует, что между серверами и клиентами существует общий язык, который позволяет каждой части быть
заменяемой или изменяемой, без нарушения целостности системы. Это достигается через четыре ограничения:

* **Определение ресурсов** – в терминологии RESTful что угодно может быть ресурсом — HTML-документ, изображение,
  информация о конкретном пользователе и т.д. Каждый ресурс должен быть уникально обозначен постоянным
  идентификатором. "Постоянный" означает, что идентификатор не изменится за время обмена данными, и даже когда изменится
  состояние ресурса. Если ресурсу присваивается другой идентификатор, сервер должен сообщить клиенту, что запрос был
  неудачным и дать ссылку на новый адрес.
* **Управление ресурсами через представления** – клиент управляет ресурсами, направляя серверу представления, обычно в
  виде JSON, содержащего представление, который он хотел бы добавить, удалить или изменить. В RESTful у сервера полный
  контроль над ресурсами, и он отвечает за любые изменения. Когда клиент хочет внести изменения в ресурсы, он посылает
  серверу представление того, каким он видит итоговый ресурс. Сервер принимает запрос как предложение, но за ним всё так
  же остаётся полный контроль.</br>
  Давайте рассмотрим блог в качестве примера. Когда пользователь создаёт новый пост в блоге, его компьютер должен
  сообщить серверу, что в блог нужно добавить новую запись. Чтобы это выполнить, он посылает POST или PUT запрос с
  содержимым в виде новой записи в блоге. Сервер возвращает ответ, указывающий, что запись создана или была
  проблема.</br>
  В не-REST мире клиент может в буквальном смысле давать инструкции операциям, вроде
  "добавить новую строку" и "присвоить записи название", вместо обычной отправки представления того, каким он видит
  конечный ресурс.
* **Самодостаточные сообщения** – каждое сообщение содержит достаточно информации для описания того, как его выполнить.
* **Hypermedia as the Engine of Application State (HATEOAS)** – клиенты предоставляют статус через содержимое body,
  параметры строки запроса, заголовки запросов и запрашиваемый URI (имя ресурса). Наряду с приведенным выше описанием,
  HATEOAS также означает, что, в случае необходимости ссылки содержатся в теле ответа (или заголовках) для поддержки URI
  извлечения самого объекта или запрошенных объектов.

### Кэширование ответа

Клиенты могут кэшировать ответы. Для предотвращения повторного использования клиентами устаревших или некорректных
данных в ответ на дальнейшие запросы сервер должен явно указывать в ответе невозможность кэшировать ответ. Возможность
кэшировать существует благодаря самодостаточным сообщениям. Хорошо спроектированное кэширование частично или полностью
устраняет некоторые клиент-серверные взаимодействия, не препятствуя мастабируемости и способствуя увеличению
производительности.

### Многоуровневая система

Клиент не знает, подключены ли они напрямую к серверу или общаются через посредника. Промежуточный сервер может улучшить
масштабируемость системы, обеспечивая балансировку нагрузки и предоставляя общий кэш. Слои также могут отвечать за
политику безопасности.

### Code-on-demand

Серверы могут временно расширять или кастомизировать функционал клиента, передавая ему логику, которую он может
исполнять. Например, это могут клиентские скрипты на Javascript (jsoup).

## Построение RESTful

HTTP глаголы составляют основную часть "единого интерфейса", ограничивающего и предоставляющего возможность осуществлять
действия над существительным-ресурсом. Основными или наиболее часто используемыми HTTP методами являются POST (создание)
, GET (чтение), PUT, PATCH (обновление) и DELETE (удаление), что в совокупности дает CRUD.

* **GET** используется для получения (или чтения) представления ресурса. В случае успеха GET возвращает представление
  ресурса в запрошенном формате (обычно JSON, но может быть XML, plain text, HTML) в сочетании с кодом состояния HTTP
  200 (OK). В отсутствия ресурса, обычно возвращается 404 Not Found. В соответствии со спецификацией HTTP, GET (так же
  как HEAD) запросы используются только для чтения данных, не изменя их, соответственно, они являются идемпотентными.
  ```shell
  # получение всех пользователей
  # request:
  GET http://localhost:8080/api/v1/users/
  # response:
  200 OK
  [
    { "id": 1, "name": "Alex", "surname": "Romanow", "active": true },
    { "id": 2, "name": "Grigory", "surname": "Shetinin", "active": true },
  ]
  
  # получение пользователя по id
  # request:
  GET http://localhost:8080/api/v1/users/1
  # response:
  200 OK
  { "id": 1, "name": "Alex", "surname": "Romanow", "active": true }
  
  # поиск активного пользователя по имени
  # request:
  GET http://localhost:8080/api/v1/users?name=Alex&active=true
  # response:
  200 OK
  [
    { "id": 1, "name": "Alex", "surname": "Romanow", "active": true }
  ]
  ```
* **POST** запрос наиболее часто используется для создания новых ресурсов. На практике он используется для создания
  вложенных ресурсов. Другими словами, при создании нового ресурса, POST запрос отправляется к родительскому ресурсу и,
  таким образом, сервис берет на себя ответственность на установление связи создаваемого ресурса с родительским
  ресурсом, назначение новому ресурсу ID и т.п. При успешном создании ресурса возвращается HTTP код 201, а также в
  заголовке "Location" передается адрес созданного ресурса. POST не является безопасным или идемпотентным запросом. В
  результате выполнения идентичных POST запросов предоставляются сильно похожие, но не идентичные данные. Так же может
  использоваться как метод применения над ресурсом некоторых действий.
  ```shell
  # Создание нового пользователя
  # request:
  POST http://localhost:8080/api/v1/users -d '{ "name": "Alex", "surname": "Romanow" }'
  # reponse:
  201 Created
  Location: http://localhost:8080/api/v1/users/1
  
  # Активация пользователя
  # request:
  POST http://localhost:8080/api/v1/users/1/activate
  # response:
  200 OK
  { "id": 1, "name": "Alex", "surname": "Romanow", "active": true }
  ```
* **PUT** метод обычно используется для предоставления возможности обновления ресурса. Тело запроса при отправке
  PUT-запроса к существующему ресурсу URI должно содержать полностью обновленное представление оригинального ресурса.
  Кроме того, PUT может быть использован для создания ресурса, в случае, когда идентификатор ресурса выбирает клиент, а
  не сервер. Или, если перефразировать – при отправке PUT запроса по адресу, содержащему не существующий идентификатор
  ресурса, сервер создает этот ресурс с переданным идентификатором. Но для создания новых экземпляров ресурса
  предпочтительнее использование POST запроса, потому что ответственность за валидный идентификатор ресурса лежит на
  сервере. При успешном обновлении выполнения PUT может возвращаться код 200 Ok + представление ресурса или 204 No
  Content, когда ответ совпадает с переданными данными из запроса. PUT не безопасная операция, так как в следствии её
  выполнения происходит модификация (или создание) экземпляров ресурса на стороне сервера, но этот метод идемпотентен.
  Другими словами, при создании или обновление ресурса с помощью PUT запроса, ресурс не исчезнет, будет располагаться
  там же, где и был при первом обращении, а также, многократное выполнение одного и того же PUT запроса не изменит
  общего состояния системы (за исключением первого раза, но это обычно опускают из рассмотрения). Строго рекомендуется
  выдерживать идемпотентность PUT запроса.
  ```shell
  # Создание пользователя с id = 3
  # request:
  PUT http://localhost:8080/api/v1/users/3 -d '{ "name": "Alex", "surname": "Romanow" }'
  # response
  200 OK
  { "id": 3, "name": "Alex", "surname": "Romanow", "active": false }
  
  # Полное обновление пользователя с id = 3
  # request:
  PUT http://localhost:8080/api/v1/users/3 -d '{ "name": "Max", "surname": "Ivanov", "active": true }'
  # response
  200 OK
  { "id": 3, "name": "Max", "surname": "Ivanov", "active": true }
  ```
* **PATCH** метод служит для модификации существующего ресурса. Возможна передача не полного представления, а только
  полей, которые требуется изменить. Метод небезопасен, т.к. в процессе происходит изменение ресурса, но идемпотентен.
  ```shell
  # обновление пользователя с id = 1
  # request:
  PATCH http://localhost:8080/api/v1/users/1 -d '{ "name": "Andrew" }'
  # response:
  200 OK
  { "id": 1, "name": "Andrew", "surname": "Romanow", "active": true }
  ```
* **DELETE** используется для удаления ресурса, идентифицированного конкретным ID. При успешном удалении возвращается
  200 OK с данными удаленного ресурса или 204 No Content без тела ответа. Согласно спецификации HTTP, DELETE запрос
  идемпотентен. Если вы выполняете DELETE запрос к ресурсу, он удаляется. Повторный DELETE запрос к ресурсу закончится
  также: ресурс уже удален. Однако повторный DELETE запрос к ресурсу часто сопровождается 404 Not Found по причине того,
  что ресурс уже удален (например из базы данных) и более не доступен. Это делает DELETE операцию не идемпотентной, но
  это общепринятый компромисс на тот случай, если ресурс был удален из базы данных, а не помечен, как удаленный.
  ```shell
  # Удаление пользователя c id = 1
  # request
  DELETE http://localhost:8080/api/v1/users/1
  # response
  204 No Content
  ```
С точки зрения RESTful-сервиса, операция идемпотентна тогда, когда клиенты могут делать один и тот же вызов неоднократно
при одном и том же результате. Другими словами, создание большого количества идентичных запросов имеет такой же эффект,
как и один запрос. Некоторые HTTP-методы (например: HEAD, GET, OPTIONS и TRACE) определены как безопасные, это означает,
что они предназначены только для получения информации и не должны изменять состояние сервера. По определению, безопасные
операции идемпотентны, так как они приводят к одному и тому же результату на сервере.

Фактически RESTful API - это всего лишь набор URI, HTTP вызовов к этим URI и некоторое количество представлений ресурсов
нужном формате JSON (XML, HTML, plain text, etc.), многие из которых будут содержать перекрестные ссылки. За основу
адресации берется покрытие уникальными идентификаторами ресурсов (URI) У каждого ресурса есть свой адрес или URI: вся
интересная информация, которую сервер может предоставить, представлена как ресурс. Ограничение однообразия интерфейса
частично реализовано с помощью комбинаций URI и HTTP глаголов и их использованием в соответствии со стандартами и
конвенциями.

Когда вы решаете, какие ресурсы буду в вашей системе, называйте их существительными, в противоположность глаголам, или
действиям. Другими словами, URI должен ссылаться на ресурс, а не на действие. Каждый ресурс сервиса должен иметь хотя бы
один URI, идентифицирующий его. И лучше всего, когда этот URI имеет смысл и адекватно описывает этот ресурс. URI должны
иметь предсказуемую, иерархическую структуру, чтобы увеличить понятность и читабельность. Это означает, что операции над
ресурсами должны быть консистентны, а у данных должна быть структура взаимоотношений. Это не принцип и не ограничение
RESTful, но это улучшает API. Часто трудно понять, где должны быть границы, но с пониманием ваших данных вы поймете и
то, что имеет смысл возвращать как представление вашим клиентам.

### Несколько общих советов по использованию RESTful

* Использование HTTP-глаголов для описания действия над ресурсами. Любой пользователь API способен присылать GET, POST,
  PUT и DELETE глаголы, которые значительно повышают ясность того, что делает запрос. Также, GET запрос не должен
  изменять любые базовые данные ресурса.
* Рациональное название ресурсов или путей (т.е., /posts/23 вместо /api?type=posts&id=23) улучшает ясность того, что
  делает запрос.
* Использование параметров строки запроса – это очень хорошо для поиска и фильтрации данных, но плохо для имен ресурсов.
  Подходящие названия ресурсов предоставляют контекст для запроса и делают API сервиса более понятным. Ресурсы
  рассматриваются иерархически через их имена URI, предлагая клиентам простую иерархию ресурсов для достижения цели в
  своих приложениях. Имена ресурсов должны быть существительными – избегайте глаголов в качестве имен ресурсов, это дает
  больше ясности. Чтобы указать глагол в запросе, используйте HTTP методы.
* Сначала гораздо проще создавать API, которые имитируют основной домен приложения или архитектуру базы данных вашей
  системы. В дальнейшем, станет понятна необходимость объединения сервисов, которые используют несколько основных
  ресурсов, чтобы избежать избыточности информации. Но позже гораздо проще создать большие ресурсы из отдельных
  ресурсов, чем детальные ресурсы от более крупных агрегатов. Легко начать с маленьких, легко определяемых ресурсов,
  обеспечивая функциональность CRUD. Ресурсы без лишней информации, ориентированные на конкретные ситуации, можно
  сделать позже.

## Hypermedia REST (HATEOAS)

Еще одним принципиальным нововведением, представленным в RESTful и используемым для уменьшения связанности клиента с
сервером, является гиперсреда, используемая в качестве механизма определения состояния приложения, часто обозначаемая
аббревиатурой̆ HATEOAS (Hypermedia As The Engine Of Application State).

Суть HATEOAS состоит в подходе к описанию ресурсов нашего API. Вместо простого перечисления набора ресурсов, со списком
всех возможных операций, которые клиент может вызвать, руководствуясь некоторой внутренней логикой, мы проводим инверсию
контроля — теперь за состояние ресурса отвечает сервер и он диктует клиенту, какие операции над ресурсом можно совершить
в текущий момент. Эта информация должна присутствовать в самом представлении ресурса, который получает клиент. Таким
образом, представление ресурса само себя описывает в достаточной степени, чтобы клиент понял, что с ним можно делать.
Рассмотрим торговый̆ сайт Amazon.com. Со временем местонахождение корзины для виртуальных покупок меняется. Меняется
графическое представление, меняется ссылка. Но люди достаточно сообразительны для того, чтобы все равно распознавать эту
корзину и работать с нею. Мы понимаем, что означает корзина для покупок, даже если изменяются её конкретная форма и
используемый элемент управления. Мы знаем, что при желании увидеть корзину нам нужно работать вот с этим элементом
управления. Таким образом, до тех пор пока клиент все еще будет в состоянии находить элемент управления,
соответствующий̆ его представлению протокола, мы можем полностью изменить реализацию представления элемента управления.

Гиперсреда является понятием, в соответствии с которым часть содержимого содержит ссылки на другие части содержимого.
Тем же самым занимается типовая веб-страница: для просмотра родственного содержимого вы следуете по ссылкам, являющимся
формой̆ элементов управления. Применение такого подхода обычно означает, что клиент знает некоторый конечный набор
"точек входа", с которых он начинает свое взаимодействие с API, используя предоставленную в представлении ресурса
информацию для навигации к другим ресурсам и совершения действий. Для достижения этой задачи как раз и используются
гиперссылки (hypermedia):

* Все ресурсы адресуемы при помощи ссылок, причем ссылки на другие ресурсы присутствуют внутри самих сообщений для их
  связи между собой. Клиент вместо ориентации на формат URI руководствуется идентификаторами, по которым он выбирает
  ссылки, располагающиеся прямо в представлении ресурса. Если ранее мы указывали в документации, что нужно взять
  некоторый ID и на его основе построить специальный URL, тем самым делая наборы URL частью нашего API, то теперь детали
  формирования URL являются просто особенностями реализации сервера и клиента не волнуют. В конце концов, клиенту важно
  получить доступ к ресурсу, а не генерировать URL по шаблонам из документации.
* Доступные операции над ресурсом тоже представимы в виде ссылок. Отсутствие ссылки как на связанные ресурсы, так и на
  доступные действия означает, что данная операция недоступна в текущем состоянии ресурса.

При преобразовании API к Hypermedia мы уже не можем говорить, что его формат чистый application/json. Дело в том, что
стандарт, описывающий этот тип, не предусматривает никакого места или механизма для определения ссылок в нем. И даже
если сформированное сообщения содержит ссылки, то машина не может отличить их от строки, в которой содержится текст по
формату напоминающий ссылку. Нам же нужно однозначно определить, где в сообщении ссылка, а где нет, поэтому здесь
используется производный тип.

Самый простой способ решить эту задачу – определить собственный тип, содержащий семантическое описание свойств и детали
взаимодействия клиента с сервером. Такие типы называются vendor specific, поскольку часто создаются под конкретную
задачу и конкретной организацией. Их нет необходимости регистрировать в IANA. Рекомендуется давать им название вида
application/vnd.${vendor}+${base_format}, где ${vendor} — это перевернутый домен компании, ${base_format} — тип который
мы взяли за основу. На первый взгляд, vendor specific типы решают возникшую проблему со ссылками, но у них есть и свои
проблемы: они не совместимы между собой и в случае работы с разными API требуется поддержка каждого из них. На деле все
эти типы отличаются друг от друга минимально. Все они направлены на решение двух вопросов: как найти все hypermedia
ссылки внутри и как найти все свойства описываемого ресурса. Для решения этих вопросов введен специальный тип – HAL (
Hypertext Application Language), описывающийся в Content-Type как application/hal+json.

## OpenAPI

Спецификация OpenAPI определяет стандарт независимого от языка описания API интерфейса, который предоставляет
возможность людям и машинам понимать возможности сервиса без доступа к исходному коду, документации или через перехват
сетевого трафика. Фактически, OpenAPI – это описание методов API, для которых описываются заголовки, входные и выходные
данные. Для описания обычно используется json или yaml, пример [Person Service](person-service.yaml). Для отображения
используется реализация [Swagger UI](https://petstore.swagger.io/).

Существует два подхода к работе с OpenAPI:

* Contract First – сначала руками описывается и согласовывается со всеми заинтересованными сторонами контракт, а потом
  по этому контракту генерируется код. Этот подход является хорошей практикой при согласовании сложных взаимодействий,
  т.к. программисты не бросаются писать код, а сначала продумывают контракт, в процессе прорабатывая все возможные
  сценарии взаимодействия. Но из-за того, что генерация кода всегда создает не оптимальный и некрасивый код, более
  распространен второй вариант – code first.
* Code First – сначала разработчики пишут код контроллеров, а потом по этому коду генерируется описание. Этот подход
  занимает больше времени, но в процессе описания контроллеров можно использовать Test Driven Development (TDD), что в
  результате даст хорошее покрытие тестами и проработку уже внутренних особенностей реализации. Но стоит понимать, что
  при необходимости согласовывать контракт с потребителями сервиса, он может меняться, из-за этого этот подход более
  затратный по ресурсам.

## Примеры

[RESTful](https://github.com/Romanow/restful)

## Литература

1. [Подходы к проектированию RESTful API](https://habr.com/ru/company/dataart/blog/277419/)
1. [Изучаем REST: Руководство по созданию RESTful-сервиса](https://www.restapitutorial.ru/)
1. [REST: простым языком](https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78)
1. [Дизайн REST API для высокопроизводительных систем](https://habr.com/ru/post/323010/)
1. [https://habr.com/ru/post/559128/](https://habr.com/ru/post/559128/)
1. [What Is A Rest Api](https://www.testmanagement.com/blog/2020/06/what-is-a-rest-api)
1. [What is REST](https://restfulapi.net/)
1. [HATEOAS Driven REST APIs](https://restfulapi.net/hateoas/)
1. [Hypermedia — то без чего ваше API не совсем REST](https://habr.com/ru/company/aligntechnology/blog/281206/)
1. [OpenAPI Specification](https://swagger.io/specification/)
1. [Swagger Editor](https://editor.swagger.io/)